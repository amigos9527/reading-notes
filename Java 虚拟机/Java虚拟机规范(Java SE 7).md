## Java虚拟机结构

​	Java虚拟机所支持的原始数据类型包括了数值类型（Numeric）、布尔类型（Boolean）和returnAddress类型三类。其中数值类型又分为整型类型和浮点类型两种，其中：

**整数类型包括：**

- byte类型：值为8位有符号二进制补码整数，默认值为零。
- short类型：值为16位有符号二进制补码整数，默认值为零。
- int类型：值为32位有符号二进制补码整数，默认值为零。
- long类型：值为64位有符号二进制补码整数，默认值为零。
- char类型：值为使用16位无符号整数表示的、指向基本多文本平面（Basic Multilingual Plane，BMP①）的Unicode值，以UTF-16编码，默认值为Unicode的null值（'\u0000'）。

**浮点类型包括：**

- float类型：值为单精度浮点数集合②中的元素，或者（如果虚拟机支持的话）是单精度扩展指数（Float-Extended-Exponent）集合中的元素。默认值为正数零。
- double类型：取值范围是双精度浮点数集合中的元素，或者（如果虚拟机支持的话）是双精度扩展指数（Double-Extended-Exponent）集合中的元素。默认值为正数零。

**布尔类型：**

- boolean类型：取值范围为布尔值true和false，默认值为false。

  虽然Java虚拟机定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，在Java语言之中涉及到boolean类型值的运算，在编译之后都使用Java虚拟机中的int数据类型来代替。
  Java虚拟机直接支持boolean类型的数组，虚拟机的newarray指令可以创建这种数组。

  boolean的数组类型的访问与修改共用byte类型数组的baload和bastore指令。

**returnAddress类型：**

- returnAddress类型：表示一条字节码指令的操作码（Opcode）。在所有的虚拟机支持的原始类型之中，只有returnAddress类型是不能直接Java语言的数据类型对应起来的。



**引用类型与值**

​	Java虚拟机中有三种引用类型：类类型（Class Types）、数组类型（Array Types）和接口类型（Interface Types）。这些引用类型的值分别由类实例、数组实例和实现了某个接口的类实例或数组实例动态创建。
​	其中，数组类型还包含一个单一维度（即长度不由其类型决定）的组件类型（Component Type），一个数组的组件类型也可以是数组。但从任意一个数组开始，如果发现其组件类型也是数组类型的话，继续重复取这个数组的组件类型，这样操作不断执行，最终一定可以遇到组件类型不是数组的情况，这时就把这种类型成为数组类型的元素类型（Element Type）。数组的元素类型必须是原始类型、类类型或者接口类型之中的一种。
​	在引用类型的值中还有一个特殊的值：null，当一个引用不指向任何对象的时候，它的值就用null来表示。一个为null的引用，在没有上下文的情况下不具备任何实际的类型，但是有具体上下文时它可转型为任意的引用类型。引用类型的默认值就是null。
​	Java虚拟机规范并没有规定null在虚拟机实现中应当怎样编码表示。



**运行时数据区**

- PC计数器

  Java虚拟机可以支持多条线程同时执行（可参考《Java语言规范》第17章），每一条Java虚拟机线程都有自己的PC（Program Counter）寄存器。在任意时刻，一条Java虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法（Current Method，§2.6）。如果这个方法不是native的，那PC寄存器就保存Java虚拟机正在执行的字节码指令的地址，如果该方法是native的，那PC寄存器的值是undefined。PC寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。

- Java虚拟机栈

  ​        每一条Java虚拟机线程都有自己私有的Java虚拟机栈（Java Virtual Machine Stack）①，这个栈与线程同时创建，用于存储栈帧（Frames, §2.6）。Java虚拟机栈的作用与传统语言（例如C语言）中的栈非常类似，就是用于存储局部变量与一些过程结果的地方。另外，它在方法调用和返回中也扮演了很重要的角色。因为除了栈帧的出栈和入栈之外，Java虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配②，Java虚拟机栈所使用的内存不需要保证是连续的。
  ​        Java虚拟机规范允许Java虚拟机栈被实现成固定大小的或者是根据计算动态扩展和收缩的。如果采用固定大小的Java虚拟机栈设计，那每一条线程的Java虚拟机栈容量应当在线程创建的时候独立地选定。Java虚拟机实现应当提供给程序员或者最终用户调节虚拟机栈初始容量的手段，对于可以动态扩展和收缩Java虚拟机栈来说，则应当提供调节其最大、最小容量的手段。
  ​    Java虚拟机栈可能发生如下异常情况：
   如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量时，Java虚拟机将会抛出一个StackOverflowError异常。
   如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。

- Java堆

  ​        在Java虚拟机中，堆（Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。
  ​        Java堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统（Automatic Storage Management System，也即是常说的“Garbage Collector（垃圾收集器）”）所管理的各种对象，这些受管理的对象无需，也无法显式地被销毁。本规范中所描述的Java虚拟机并未假设采用什么具体的技术去实现自动内存管理系统。虚拟机实现者可以根据系统的实际需要来选择自动内存管理技术。Java堆的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。Java堆所使用的内存不需要保证是连续的。
  ​       Java虚拟机实现应当提供给程序员或者最终用户调节Java堆初始容量的手段，对于可以动态扩展和收缩Java堆来说，则应当提供调节其最大、最小容量的手段。
  ​       Java堆可能发生如下异常情况：
   如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那Java虚拟机将会抛出一个OutOfMemoryError异常。

- 方法区

  ​        在Java虚拟机中，方法区（Method Area）是可供各条线程共享的运行时内存区域。方法区与传统语言中的编译代码储存区（Storage Area Of Compiled Code）或者操作系统进程的正文段（Text Segment）的作用非常类似，它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法（§2.9）。
  ​        方法区在虚拟机启动的时候被创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集。这个版本的Java虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。方法区的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。方法区在实际内存空间中可以是不连续的。
  ​        Java虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态扩展和收缩方法区来说，则应当提供调节其最大、最小容量的手段。
  ​        方法区可能发生如下异常情况：
   如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。

- 运行时常量池

  ​        运行时常量池（Runtime Constant Pool）是每一个类或接口的常量池（Constant_Pool，§4.4）的运行时表示形式，它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表（Symbol Table）的角色，不过它存储数据范围比通常意义上的符号表要更为广泛。
  ​        每一个运行时常量池都分配在Java虚拟机的方法区之中（§2.5.4），在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。
  ​        在创建类和接口的运行时常量池时，可能会发生如下异常情况：
   当创建类或接口的时候，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值，那Java虚拟机将会抛出一个OutOfMemoryError异常。

- 本地方法栈

  ​        Java虚拟机实现可能会使用到传统的栈（通常称之为“C Stacks”）来支持native方法（指使用Java以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（Native Method Stack）。当Java虚拟机使用其他语言（例如C语言）来实现指令集解释器时，也会使用到本地方法栈。如果Java虚拟机不支持natvie方法，并且自己也不依赖传统栈的话，可以无需支持本地方法栈，如果支持本地方法栈，那这个栈一般会在线程创建的时候按线程分配。

  ​        Java虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。如果采用固定大小的本地方法栈，那每一条线程的本地方法栈容量应当在栈创建的时候独立地选定。一般情况下，Java虚拟机实现应当提供给程序员或者最终用户调节虚拟机栈初始容量的手段，对于长度可动态变化的本地方法栈来说，则应当提供调节其最大、最小容量的手段。
  ​        本地方法栈可能发生如下异常情况：
   如果线程请求分配的栈容量超过本地方法栈允许的最大容量时，Java虚拟机将会抛出一个StackOverflowError异常。
   如果本地方法栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的本地方法栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。